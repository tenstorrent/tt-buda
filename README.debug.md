
*PyBuda monitors many environment variables to modify default behavior. These can be used to debug or analyze problems.*

## Overrides
 * PYBUDA\_BUILD\_DIR: Override the build directory for the compiler.
 * LOGURU\_LEVEL: set Python logger level - default is DEBUG, valid values are INFO, DEBUG, TRACE, NONE
 * LOGGER\_LEVEL: set C++ logger level - values are the same as Python logger
 * PYBUDA\_DEVMODE: set to make Golden/Sequential default run mode if one isn't specified explicitly
 * PYBUDA\_PROFILE: enable Python profiler
 * PYBUDA\_ASSERT\_UNSUPPORTED\_HW\_OP: assert if an unsupported op is found
 * PYBUDA\_BALANCER\_PLACER\_DATA: prints balancer/placer visual info, prints chip op group info
 * PYBUDA\_BALANCER\_POLICY\_TYPE: override balancer policy
 * PYBUDA\_SCHEDULER\_POLICY: override scheduler policy
 * PYBUDA\_BALANCER\_ONE\_ROW: limit placement to one row
 * PYBUDA\_ENABLE\_T\_STREAMING: enable t-streaming (i.e. streaming ops with small output buffers)
 * PYBUDA\_ENABLE\_TVM\_CACHE: Cache tvm graphs instead of re-compiling
 * PYBUDA\_FORCE\_FULL\_COMPILE\_DEPTH: Force each test to run to compile depth "FULL"
 * PYBUDA\_RELOAD\_GENERATED\_MODULES: Reload previously generated modules instead of recompiling through tvm.
 * PYBUDA\_SKIP\_L1\_USAGE\_VALIDATION: allows ops to use more L1 than available
 * PYBUDA\_ENFORCE\_SAME\_UBLOCK\_OPERANDS: ???
 * PYBUDA\_VERIFY\_NET2PIPE: verify produced netlist using net2pipe
 * PYBUDA\_CI\_DIR: ???
 * PYTEST\_CURRENT\_TEST: ???
 * PYBUDA\_CI\_CAPTURE\_TENSORS: save tensors used in the test so they can be used in stand-alone back-end tests
 * PYBUDA\_FORCE\_SEQUENTIAL: override test/script to run everything in sequential mode
 * PYBUDA\_TRACE\_SHUTDOWN: show stack trace on shutdown due to error
 * PYBUDA\_OVERRIDE\_NUM\_CHIPS: force the number of chips to use, instead of the auto-detected number
 * PYBUDA\_DISABLE\_DYNAMIC\_DRAM: disable dynamic allocation of e2e queues in inference
 * PYBUDA\_DISABLE\_AUTOMATIC\_DRAM\_LOGIC: disable automatic logic for static/dynamic allocation of queues. 
 * PYBUDA\_DISABLE\_FORK\_JOIN\_BUF: disable fork-join buffering
 * PYBUDA\_DISABLE\_FORK\_JOIN\_NOPS: don't insert nops if there's not enough buffering. Just add what's available in L1. This should only be used for debug.
 * PYBUDA\_FORK\_JOIN\_DEBUG\_INFO: print debug logs related to fork-join buffering
 * PYBUDA\_FORK\_JOIN\_DEBUG\_FORK\_NAME: filter debug logs (generated by PYBUDA\_FORK\_JOIN\_DEBUG\_INFO) by fork node name
 * PYBUDA\_FORK\_JOIN\_DEBUG\_JOIN\_NAME: filter debug logs (generated by PYBUDA\_FORK\_JOIN\_DEBUG\_INFO) by join node name
 * PYBUDA\_FORK\_JOIN\_SKIP\_EXPANDING\_BUFFERS: don't expand buffers in L1 - this will cause algorithm to add buffering nops/queues any time a fork-join needs to be buffered.
 * PYBUDA\_FORK\_JOIN\_EXPAND\_OUTPUT\_BUFFERS: expand only output buffers (instead of input buffers) for fork-join buffering
 * SHOW\_ALL\_FAILS: don't assert on the first data mismatch, but show all fails before failing the test
 * PYBUDA\_EXP\_APPROX: run exp in approximate mode
 * PYBUDA\_VERIFY\_RESULTS\_OFF\_BY\_DEFAULT: disable result verification (tensor comparison of processed and golden module done via forward pass)
 * PYBUDA\_ENABLE\_STABLE\_SOFTMAX: enable stable Softmax (disabled by default)
 * EVAL\_DEBUG: prints inputs/outputs during module evaluation
 * TT\_BACKEND\_GOLDEN\_QUANTIZE: ???
 * PYBUDA\_RESET\_DEV\_BEFORE\_TEST: resets device between tests (pytest must be called with --forked in order to work)
 * PYBUDA\_PERF\_SIMULATOR: run performance simulator to estimate performance of the model
 * PYBUDA\_PERF\_SIMULATOR\_LOG: dump log of all events in perf simulator (will slow down the run)
 * PYBUDA\_PERF\_SIMULATOR\_TRACE: create trace file to be loaded into routeagui
 * PYBUDA\_OP\_PERF: dump op\_perf.csv file with op grid choices and estimated cycle counts
 * <u>PYBUDA\_BENCHMARK\_NO\_RESET\_ON\_ERROR: from the comments seems that it doesn't work, should we remove this one?</u>
 * PYBUDA\_SKIP\_BACKEND\_COMPILE: configure backend device to run in DeviceMode.RunOnly, picking up build binaries from previous run
 * PYBUDA\_PLACER\_BWD\_GROUPS: use bwd groups when placing so that fwd and bwd ops are placed together
 * PYBUDA\_TRIPLET\_PLACEMENT: try to place bwd groups in "triplet" placement strategy
 * PYBUDA\_EXP\_APPROX: force exp and exponent in gelu\_derivative to run in approximate mode (i.e. faster, but less accurate)
 * PYBUDA\_AMP\_LEVEL: configure the AMP (Automatic Mixed Precision) optimization level.
 * PYBUDA\_NO\_FUSE\_MATMUL\_BIAS: disable fusing of matmul+add into matmul
 * PYBUDA\_ENABLE\_OUTPUT\_QUEUES\_ON\_HOST: configures whether whether output queues are placed on HOST (default: true)
 * PYBUDA\_FORCE\_VERIFY\_ALL: ensure that verification is run after each compile stage, overrides VerifyCondig.disabled()
 * PYBUDA\_VERIFY\_POST\_AUTOGRAD\_PASSES: verify graph after post autograd passes, unless the verify config is VeifyConfig.disabled()
 * PYBUDA\_VERIFY\_POST\_PLACER: verify graph after post placer pass, unless the verify config is VeifyConfig.disabled()
 * PYBUDA\_GALAXY\_LINEAR\_ROUTE: place graphs sequentially in a snake route around the Galaxy modules
 * PYBUDA\_NEBULA\_GALAXY\_PLACER: only place output nop on mmio chip for untilizing
 * PYBUDA\_ENABLE\_AUTO\_TRANSPOSE: configures whether auto-transpose is enabled while op placement (default: false)
 * PYBUDA\_MINIMIZE\_REMOTE\_DRAM\_QUEUES: configures behaviour for data forking to remote chips - create single e2e queue on producer or e2e queue per consumer chip (default)
 * PYBUDA\_SPARSE\_MM\_ENCODING\_ESTIMATES\_OFF: when on, turns off estimation logic for in0/in2 for sparse mm, but gets slower
 * PYBUDA\_REBLOCK\_INPUT\_ACT: when enabled, we reblock input activations to the smallest grid across all users instead of forcing 1x1. (default: disabled)
 * PYBUDA\_DUMP\_MIXED\_PRECISION: when on, dump json with a per-op info about fidelity, data-formats (default: off). Default directory: reportify dump directory.
 * PYBUDA\_PRESTRIDE\_DISABLE: disables prestriding transform for convs
 * PYBUDA\_LEGALIZER\_DETAILED\_DEBUGGING: when on provides detailed debugging information and statistics about legalizer OpModel selection process including GraphSolver. Works only in DEBUG(default: off).
 * PYBUDA\_LEGALIZER\_DEBUG\_NODE\_NAME: used together with legalizer detailed debugging to narrow down debugging info to single node. Works only in DEBUG(default: off).
 * PYBUDA\_GRAPHSOLVER\_SELF\_CUT\_TYPE: Override for graph_solver_self_cut_type in BalancerConfig. Valid values: None, ConsumerOperandDataEdgesFirst, ProducerUserDataEdgesFirst, FastCut. When switched on(not None) graphsolver will cut edges for which it cannot produce valid paths. (default: None)
 * PYBUDA\_MAX\_GRAPH\_CUT\_RETRY: Override for default_resolve_retry_count_self_cutting in GraphSolver::resolve. This sets the max retry step if GraphSolver self cut is turned on.
 * PYBUDA\_REPLACE\_INF\_IN\_TVM\_PARAMS: Replace -inf and inf values from TVM parameters during PyBuda code generation.
 * PYBUDA\_DISABLE\_FUSE\_TAGS: Specify a list of ops (comma delimited) by original_op_type/op_type that will be exempt from fusion (e.g. PYBUDA\_DISABLE\_FUSE\_TAGS="reciprocal,softmax").
 * PYBUDA\_BISECT\_FUSING: bool, false by default. When it is set to true, we bisect fusing by defining PYBUDA\_FUSE\_OP\_FIRST\_IND and PYBUDA\_FUSE\_OP\_LAST\_IND.
 * PYBUDA\_FUSE\_OP\_FIRST\_IND: First index in topologically sorted graph of ops to fuse.
 * PYBUDA\_FUSE\_OP\_LAST\_IND: Last index in topologically sorted graph of ops to fuse.
 * PYBUDA\_SINGLE\_OP\_EPOCHS: Place every single op on a new epoch.
 * PYBUDA\_FORK\_JOIN\_BUF\_QUEUES: Turn on adding buffering queues instead of nops in fork joins that need a lot of buffering (have one path much larger than the other).
 * PYBUDA\_RESNET\_BUFF\_QUEUE\_OVERRIDE: Turn off adding buffering queues in graph solver cut. Temporal fix for ResNet perf.
 * PYBUDA\_OVERRIDE\_DEVICE\_YAML: Override the soc device descriptor to compile against different device configurations.
 * PYBUDA\_DISABLE\_INTERACTIVE\_PLACER: Override balancer policy not to use Interactive placer and to fallback to legacy placer instead. (default: 0/False)
 * PYBUDA\_DISABLE\_INTERACTIVE\_FJ\_BUFFERING: Override balancer policy not to use inlined fork-join buffering. (default: 0/False)
 * PYBUDA\_DISABLE\_PADDING\_PASS\: Disable running of padding pass.
 * PYBUDA\_PADDING\_PASS\_ELEMENT\_WISE: In padding pass pad elementwise ops.
 * PYBUDA\_PADDING\_PASS\_MATMUL: In padding pass pad matmul ops.
 * PYBUDA\_PADDING\_PASS\_SPARSE\_MATMUL: In padding pass pad sparse matmul ops. Needs to have matmul ops enabled for padding too in order to enable this.
 * PYBUDA\_PADDING\_PASS\_BUFFER\_QUEUE": Enable padding pass, insert buffer queue
 * PYBUDA\_ENABLE\_STOCHASTIC\_ROUNDING": Enable stochastic rounding for all supported ops.
 * PYBUDA\_PADDING\_PASS\_CONCAT": Enable padding pass, for concatenate operation
 * PYBUDA\_FORCE\_CONV\_MULTI\_OP\_FRACTURE: Forces all convs to be fractured (during decompose pass) according to heuristic defined in `pybuda/pybuda/op/eval/pybuda/convolution.py`.
 * PYBUDA\_COLLECT\_CONSTRAINT\_INFO: Enables constraint info collection on every graphsolver resolve.
 * PYBUDA\_GRAPHSOLVER\_FAST: Enables partial re-resolve on cut and buffer, much faster at cost of not enabling all possible valid OpModels.
 * NUM\_EXEC\_LOOP\_ITERATIONS: For single temporal epoch tests, you can specify a # here that will rerun the epoch the specified # of times. Each rerun is initiated by FW rather than requiring host interaction, to improve performance.
 * PYBUDA\_PADDING\_PASS\_DISABLE\_BUDA\_OP: Disable padding logic that uses buda implementation for pad and unpad.
 * PYBUDA\_ENABLE\_ETH\_SERIALIZATION: Enable the ethernet stream reduction pass, using the ethernet datacopy op to implement the stream reduction
 * PYBUDA\_ENABLE\_ETH\_DATACOPY\_SERIALIZATION: Enable the ethernet stream reduction pass, using the tensix datacopy/nop op to implement the stream reduction. Will only insert datacopy ops if there are free tensix cores
 * PYBUDA\_SUPRESS\_T\_FACTOR\_MM: Enables a condition in calculate_op_model in legalizer that limits the t factor of sparse/dense matmul ops to be less than the flag's value. Valid values: any positive int value (eg. 16)
 * PYBUDA\_AMP\_LIGHT: Enable a "light" version of mixed precision to minimize accuracy impact (default: 0/False; 1: bfp8/hifi2, 2: bfp4/hifi2, 3: bfp4/LoFi)
 * PYBUDA\_GRAPH\_NAME\_SUFFIX: Suffix to add to the graph name (helps to generate unique netlist names)
 * PYBUDA\_DISABLE\_L1\_ACCUMULATE: Flag for disabling and debugging L1 accumaulation feature.
 * PYBUDA\_OVERRIDE\_VETO: Used to Add/Remove/Update general and env var based compiler configurations. 
 * PYBUDA\_DISABLE\_REPORTIFY\_DUMP: Disable generating reportify graph. 
 * PYBUDA\_DISABLE\_CAP\_SPARSE\_MM\_FIDELITY: Disables an optimization to cap the fidelity phases of sparse matmul to at most HiFi2.
 * PYBUDA\_DISABLE\_EXPLICIT\_DRAM\_IO: Disables the FE from programming netlist attribute `input_dram_io_buf_size_tiles`.  Instead the FE will leave this attribute as `0` which implicitly means that the backend will handle the allocation of this buffer.
 * PYBUDA\_CONCAT\_ON\_HOST: Lower concatenate ops on output nodes into runtime transforms so that they're done on host.
 * PYBUDA\_OP\_MODEL\_COMPARE\_VERSION: Version of op model comparision function. Can be used to compare effect of different comparison logic on performance.
 * PYBUDA\_RIBBON1\_PREPASS\_ENABLED: Whether to use or not suboptimal opmodel invalidation prepass. Default value is False.
 * PYBUDA\_RIBBON2\_CONSERVATIVE\_OPTIMIZATION\_ITERATIONS: Number of optimization iterations in Ribbon2 balancing policy per epoch. Default value is 10.
 * PYBUDA\_RIBBON2\_DISABLE\_CLEANUP\_BUF\_NOPS: Disable cleanup of unneeded buffering nops in Ribbon2. (default: 0/False)
 * PYBUDA\_RIBBON2\_CALCULATE\_TARGET\_CYCLES: Calculate target cycles for every epoch within Ribbon2 balancing policy. (default: 0/False)
 * PYBUDA\_RIBBON2\_CALCULATE\_TARGET\_CYCLES\_APPLY\_FILTERING: Apply filtering on GS search space while calculating dynamic cycles per epoch within Ribbon2 balancing policy. (default: 0/False)
 * PYBUDA\_RIBBON\_LEGACY: Use legacy Ribbon balancing policy. (default: 0/False)
 * PYBUDA\_MAXIMIZE\_GRID: Reverse logic of MinimizeGrid policy. Maximize grid size for all ops. (default: 0/False)
 * PYBUDA\_ENABLE\_HOST\_INPUT\_NOP\_BUFFERING: Enable nop buffering of input host read. (default: 0/False)
 * PYBUDA\_AUTO\_RECOMPILE: Triggers handling of backend compile error and recompiles the model. (default: 1/True)
 * PYBUDA\_AUTO\_RECOMPILE\_TARGET\_CYCLES: Enables adjustment of target cycles during recompile if no errors from backend have been previously handled. Requires PYBUDA\_AUTO\_RECOMPILE to be enabled to work. (default: 0/False)
 * PYBUDA\_AUTO\_RECOMPILE\_RETRY\_LIMIT: Limits number of attempts to recompile. (default: 10)
 * PYBUDA\_TARGET\_CYCLES\_OFFSET: Sets the desired amount by which to offset the target cycles for balancer. Default value is 0.
 * PYBUDA\_ENABLE\_VERSIM\_DEVICE: The Versim device is a specific silicon simulation device that PyBUDA supports.The variable is used to enable the Versim device in the PyBUDA pytest environment. By setting this variable to 1, we are instructing PyBUDA to use the Versim device as the target device instead of the silicon or golden device. Enabling the Versim device can be useful for testing or experimentation purposes, allowing us to evaluate the behavior of our code on this simulation device and specified architecture. In order to run Versim device as a targeted device, the source code must be built with UMD_VERSIM_STUB=0 enviroment variable.
 * PYBUDA\_VERSIM\_DEVICE\_ARCH: This env variable represents the architecture of the Versim device used in the pytest.
 * PYBUDA\_ENABLE\_EMULATION\_DEVICE: This device is a specific silicon emulation device that PyBUDA supports. The variable is used to enable emulation device in PyBUDA pytest environment. By setting this variable to 1, we are instructing PyBUDA to use the emulation device as the target device instead of the silicon or golden device. Enabling the emulation device can be useful for testing or experimentation purposes, allowing us to evaluate the behaviour of our code on this emulation device. In order to run emulation device as a targeted device, the source code must be built with EMULATION_DEVICE_EN=1 environment variable.
 * PYBUDA\_EMULATION\_DEVICE\_ARCH: This env variable represents the architecture of the emulation device used in the pytest.
 * PYBUDA\_DISABLE\_DEPTHWISE\_CONV2D\_DECOMP: If set to 1, depthwise conv2d ops will not be decomposed using the depthwise op and instead use a matmul.

 ## Golden overrides
 * GOLDEN\_WORMHOLE\_B0: run Golden with Wormhole_B0 as target device instead of Grayskull (default)
 * PYBUDA\_GOLDEN\_BLACKHOLE: run Golden with Blackhole as target device instead of Grayskull (default)

## Temp overrides
* PYBUDA\_TEMP\_ENABLE\_NEW\_SPARSE\_ESTIMATES: Apply new formula to estimate the cycle count of sparse matmul ops (currently only support LoFi and HiFi2 fidelities)
* PYBUDA\_TEMP\_SCALE\_SPARSE\_ESTIMATE\_ARGS: Scale counts of non-zero tiles, ublocks and strips to reflect the numbers that would end up on a single core, since BBE estimates always assume grid_size [1,1].
* PYBUDA\_TEMP\_SPARSE\_ESTIMATE\_ARGS\_PER\_CORE: Instead of uniformly scaling sparse args (as happens in PYBUDA_TEMP_SCALE_SPARSE_ESTIMATE_ARGS), calculate them per core. To use, need set PYBUDA_TEMP_SCALE_SPARSE_ESTIMATE_ARGS to 1 as well.
* PYBUDA\_TEMP\_ELT\_UNARY\_ESTIMATES\_LEGACY: Force legacy path of calculating execution cycles for eltwise unary ops - instead of calling into BBE, use hand-crafted FE-side logic
* PYBUDA\_TEMP\_ENABLE\_NEW\_FUSED\_ESTIMATES: Apply new formula to estimate the cycle count of fused ops. The formula calls BBE to estimate each subop and sums up the results.
* PYBUDA\_LEGACY\_KERNEL\_BROADCAST: Use legacy kernel broadcast detection path. Will detect fewer kernel broadcasts, and will oftentimes use more tiles (longer KBs).
* PYBUDA\_TEMP\_BALANCER\_MODEL\_PCIE\_BW: Estimate PCIe bandwidth in limiter cycles. (default: 1/True)
* PYBUDA\_TEMP\_BALANCER\_DISABLE\_TARGET\_PROXIMITY: Disable target proximity in balancer. (default: 0/False)
* PYBUDA\_TEMP\_DISABLE\_FJ\_NOP\_SCHEDULE\_FIX: This flag disables a fix that forces FJ buffering nops to be scheduled last.
* PYBUDA\_TEMP\_FIX\_2351: Controls the fix for bug #2351 - fork-join can end up adding buffering nops and queues on same path, this control flag fixes it.
* PYBUDA\_TEMP\_RIBBON2\_LEGACY\_UTIL\_EVAL: Use legacy util evaluation in Ribbon2 balancing policy. (default: 0/False)
* PYBUDA\_TEMP\_DISABLE\_MODEL\_KB\_PROLOGUE\_BW: Disables bandwidth modelling for kernel broadcasted and prologued inputs.
* PYBUDA\_TEMP\_ENABLE\_SPARSE\_MM\_SERIALIZATION\_FACTOR: If enabled, accounts for serialization in sparse matmuls due to sparse tensors starting at different `m_k`s across cores.
